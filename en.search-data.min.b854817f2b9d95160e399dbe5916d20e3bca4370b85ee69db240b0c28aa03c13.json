[{"id":0,"href":"/VisualComputing/docs/taller-1/ilusiones/","title":"Ilusiones","section":"Taller 1","content":" Ilusiones # Introducción # Aquí se presentan cada una de las siguiente ilusiones con sus respectivas explicaciones sobre cómo funcionan, tratando de explicar porque se dan dichos fenómenos al analizar los diferentes componente de cada ilusiòn.\nSteping Illusion # En esta ilusion se observan dos rectangulos de color amarillo y azul que se desplazan a lo largo de un patron de barras claras y oscuras. Cuando las condiciones de color y tamaño son adecuadas los rectangulos parecen moverse de manera intermitente, como si fueran pies caminando.\nCuando el pie amarillo tiene un brillo similar a las barras claras, y el pie azul un brillo similar a las barras oscuras (caso extremo cuando son del mismo color y suficiente contraste entre los claros y los oscuros) solo hay evidencia clara de movimiento cuando los extremos del rectangulo claro pasan sobre una barra oscura o los del rectangulo oscuro pasan sobre una barra clara, efectivamente la mitad del espacio. En la otra mitad no (claro en claro o oscuro en oscuro) no es evidente el movimiento por lo que el cerebro asume que no hay movimiento (por defecto si algo no está en movimiento, entonces está en reposo).\nEste fenómeno también explica otra posible ilusión, que no se vean los rectángulos caminando si no oscilando, como un gusano. Esto se logra cuando la razón entre el largo del rectángulo y el ancho de las barras es un número impar (un número par causa la ilusión de caminar).\nAutor: Tomado de https://michaelbach.de/ot/mot-feetLin/index.htmlm, Autor: Michael Bach\nCòdigo let barWidth; let x = 0; let feetWidth; let feetHeight; let feetDistance; let speed; let direction = 1; let barWidthSlider; let feetWidthSlider; let feetHeightSlider; let feetDistanceSlider; let speedSlider; const labels = [\u0026#34;Ancho\\nBarras\u0026#34;,\u0026#34;Longitud\\nPies\u0026#34;,\u0026#34;Ancho\\nPies\u0026#34;,\u0026#34;Distancia\\nPies\u0026#34;,\u0026#34;Velocidad\u0026#34;]; function setup() { createCanvas(450, 380); frameRate(60); colorMode(HSB); barWidthSlider = createSlider(5, 50, 25); barWidthSlider.position(5, 310); barWidthSlider.style(\u0026#39;width\u0026#39;, \u0026#39;80px\u0026#39;); feetWidthSlider = createSlider(5, 150, 100); feetWidthSlider.position(90, 310); feetWidthSlider.style(\u0026#39;width\u0026#39;, \u0026#39;80px\u0026#39;); feetHeightSlider = createSlider(5, 0.5*(height-80), 25); feetHeightSlider.position(175, 310); feetHeightSlider.style(\u0026#39;width\u0026#39;, \u0026#39;80px\u0026#39;); feetDistanceSlider = createSlider(0, (height-80), 40); feetDistanceSlider.position(260, 310); feetDistanceSlider.style(\u0026#39;width\u0026#39;, \u0026#39;80px\u0026#39;); speedSlider = createSlider(0, 300, 100); speedSlider.position(345, 310); speedSlider.style(\u0026#39;width\u0026#39;, \u0026#39;80px\u0026#39;); } function draw() { speed = direction * speedSlider.value()/100; barWidth = barWidthSlider.value(); if (x + feetWidthSlider.value() \u0026lt;= width){ feetWidth = feetWidthSlider.value(); } feetHeight = feetHeightSlider.value(); if (feetDistanceSlider.value() \u0026lt;= (height-80)-2*feetHeight){ feetDistance = feetDistanceSlider.value(); }else{ feetDistance = (height-80)-2*feetHeight; } background(0,0,98); stroke(0,0,0); fill(0,0,0); for (let i = 0; i \u0026lt; width; i = i + 2 * barWidth) { rect(i,0,barWidth,(height-80)); } stroke(60,100,100); fill(60,100,100); rect(x,(0.5*(height-80))-feetHeight-0.5*feetDistance,feetWidth,feetHeight); stroke(240,100,40); fill(240,100,40); rect(x,(0.5*(height-80))+0.5*feetDistance,feetWidth,feetHeight); x = x + speed; if (x \u0026gt;= width-feetWidth) { direction = -1; } if (x \u0026lt;= 0) { direction = 1; } stroke(0,0,100); fill(0,0,100); rect(0,300,width,80); textSize(16); textAlign(CENTER); stroke(0,0,0); fill(0,0,0); text(labels[0], 45, 347); text(labels[1], 130, 347); text(labels[2], 215, 347); text(labels[3], 300, 347); text(labels[4], 385, 347); } Complementary Colors # Existe algo llamado \u0026ldquo;imagen remanente retiniana negativa\u0026rdquo;. Se vuelve visible cuando un tono determinado permanece en la misma posición de la retina durante varios segundos (por lo general, moveríamos los ojos 3 veces por segundo, por lo que esto no es una desventaja en la visualización normal). La imagen remanente se acumula a medida que esa ubicación retiniana se adapta a este tono especial, y al mirar un fondo neutro se ve el color complementario. Investigaciones recientes han localizado de manera convincente las células ganglionares de la retina como sustrato neural para la imagen residual (Zaidi et al. 2012).\nEsto es algo bueno, normalmente, porque ayuda a la \u0026ldquo;constancia del color\u0026rdquo;, es decir, vemos colores algo independientes de la iluminación ambiental (compare el sol glaciar azulado del mediodía con un tinte rojizo en la sala de estar junto a la chimenea).\nEntonces la imagen residual está \u0026ldquo;grabada\u0026rdquo;, lo que significa que la ubicación de la retina está adaptada. Ahora el parche magenta cambia repentinamente a gris. Por la adaptación, ahora se ve el color complementario, que sería el verde para el magenta, o el gris claro para un gris oscuro.\nLa imagen residual de la retina generalmente se desvanece rápidamente (en unos pocos segundos en condiciones normales). Pero aquí este desvanecimiento no reduce la percepción de la imagen remanente, porque se descubre una nueva justo después en la siguiente ubicación.\nAdemás, un efecto Gestalt, aquí entra en juego el \u0026ldquo;fenómeno phi\u0026rdquo;: la imagen residual de las sucesivas ubicaciones retinianas se integra y se percibe como un solo objeto en movimiento, a saber, el disco verde.\nEn resumen, los siguientes factores hacen que esta ilusión sea bastante convincente:\nEs bastante fácil fijarse constantemente en el centro La mayoría de las veces, las ubicaciones de la retina se readaptan y la imagen remanente se descubre solo brevemente Un efecto Gestalt conduce a la percepción de un disco verde volador. Tomado de https://michaelbach.de/ot/col-lilacChaser/index.html, Autor: Michael Bach\nCòdigo let colors = []; let maincolor let flag = false; let select function setup() { createCanvas(500, 500); angleMode(DEGREES); select = createSelect(); select.option(\u0026#39;magenta\u0026#39;); select.option(\u0026#39;yellow\u0026#39;); select.option(\u0026#39;cyan\u0026#39;); select.option(\u0026#39;red\u0026#39;); select.option(\u0026#39;blue\u0026#39;); select.option(\u0026#39;green\u0026#39;); select.option(color(255, 216, 255)); /* magenta with 15% saturation */ select.option(color(255, 255, 216)); /* yellow with 15% saturation */ select.option(color(216, 255, 255)); /* cyan with 15% saturation */ select.changed(selectEvent); maincolor = select.value() colors = [color(maincolor), color(maincolor), color(maincolor), color(maincolor), color(maincolor), color(maincolor), color(maincolor), color(maincolor), color(maincolor), color(maincolor), color(maincolor), color(maincolor)] } function draw() { background(240); strokeWeight(1); noStroke(); fill(240); circle(250, 250, 400); let p0 = createVector(450, 250); let p30 = createVector(cos(30)*200 + 200 + 50, (1-sin(30))*200 + 50); let p60 = createVector(cos(60)*200 + 200 + 50, (1-sin(60))*200 + 50); let p90 = createVector(250, 50); let p120 = createVector((1-(-cos(120)))*200 + 50, (1-sin(120))*200 + 50); let p150 = createVector((1-(-cos(150)))*200 + 50, (1-sin(150))*200 + 50); let p180 = createVector(50, 250); let p210 = createVector((1-(-cos(210)))*200 + 50, -sin(210)*200 + 200 + 50); let p240 = createVector((1-(-cos(240)))*200 + 50, -sin(240)*200 + 200 + 50); let p270 = createVector(250, 450); let p300 = createVector(cos(300)*200 + 200 + 50, -sin(300)*200 + 200 + 50); let p330 = createVector(cos(330)*200 + 200 + 50, -sin(330)*200 + 200 + 50) point(p0); point(p30); point(p60); point(p90); point(p120); point(p150); point(p180); point(p210); point(p240); point(p270); point(p300); point(p330); noStroke(); fill(colors[0]); circle(p0.x, p0.y, 60); fill(colors[1]); circle(p30.x, p30.y, 60); fill(colors[2]); circle(p60.x, p60.y, 60); fill(colors[3]); circle(p90.x, p90.y, 60); fill(colors[4]); circle(p120.x, p120.y, 60); fill(colors[5]); circle(p150.x, p150.y, 60); fill(colors[6]); circle(p180.x, p180.y, 60); fill(colors[7]); circle(p210.x, p210.y, 60); fill(colors[8]); circle(p240.x, p240.y, 60); fill(colors[9]); circle(p270.x, p270.y, 60); fill(colors[10]); circle(p300.x, p300.y, 60); fill(colors[11]); circle(p330.x, p330.y, 60); strokeWeight(10); stroke(1) point(250, 250) if (flag == false) go(); flag = true; } async function go() { for (let i = 0; i \u0026lt; colors.length; i++) { await sleep(200); if (i == 0) colors[colors.length - 1] = color(maincolor); else colors[i-1] = color(maincolor); colors[i] = color(240); } flag = false; } function selectEvent() { maincolor = select.value() } function sleep(ms) { return new Promise(resolve =\u0026gt; setTimeout(resolve, ms)); } Spinning Ellipses # El efecto consiste en una ilusión de movimiento, dado que es una serie de elipses que gira respecto a otro a una razón de 0.003 grados se crea un \u0026ldquo;puente\u0026rdquo; entre elipses, que a su vez crea un arco con el borde exterior de los elipses conectados subsecuentemente, mirando el punto central se puede ver como se crean dos patrones de espiral, lo que a su vez al estar rotando da esta espiral \u0026ldquo;hipnótica\u0026rdquo;. Si se mira durante un tiempo y luego se mira un fondo blanco dejará una impresión en la visión como de un halo alrededor de donde se encontraba el punto central.\nTomado de: https://youtu.be/xlPWCrjQsTE, Autor: Computing Masterclass\nCòdigo let angle = 0; function setup() { createCanvas(500, 500); strokeWeight(4); } function draw() { background(50); noStroke() fill(255,255,255) ellipse(width/2, height/2,10,10) for(let i = 15; i\u0026lt;500; i+=15){ push() //Empieza un nuevo dibujo translate(width/2,height/2) rotate(i+angle *2) noFill() stroke(i, i+100, 200) ellipse(0,0,i+20,i) //reemplazado i por slider.value pop() angle += 0.0003 } } function changeColor(){ background(bgcolor) } Moving Dots # El efecto consiste en una ilusión de movimiento, debido a que cada círculo contiene dos arcos de colores similares en movimiento de traslación sobre el mismo círculo, el ojo, al fijar su visión central solo en un punto o zona de toda la imagen, provoca que la visión periférica al captar el resto de la imagen, se dé un efecto de movimiento sobre los círculos, como si estuvieran bailando y moviéndose en forma de onda, a pesar de que el círculo central se encuentre siempre sin moverse, esto debido al movimiento contrario entre ambos arcos y que esten colocados de tal modo que, en cierto punto de rotaciòn, el circulo central queda expuesto a la zona exterior, provocando que la otra zona, con ambos arcos uno encima de otro, se vea como un circulo sin un pedazo\nTomado de : https://youtu.be/BQbrx6V0jTs, Autor: Computing Masterclass\nCòdigo let angle = 0; function setup() { createCanvas(700, 700); } function draw() { background(50); for (let i = 50; i \u0026lt; width - 45; i += 50) { for (let j = 50; j \u0026lt; height - 45; j += 50) { push() fill(0, 168, 0); stroke(0, 0, 150); strokeWeight(3); ellipse(i, j, 25, 25); pop() push() translate(i, j); rotate(HALF_PI + i - angle * 3) stroke(0, 168, 168); strokeWeight(3); noFill(); arc(0, 0, 30, 30, 0, PI) pop() push() translate(i, j); rotate(QUARTER_PI * j + angle * 4) stroke(0, 255, 255); strokeWeight(3); noFill(); arc(0, 0, 25, 25, PI , 0) pop() angle += 0.0005 } } } Conclusiones # Las ilusiones ópticas son efectos que logran engañar nuestro cerebro provocando que veamos cosas que no necesariamente ocurren de dicho modo, en este caso se presentaron, a través de ilusiones generada con código en p5 sin truco\nLas ilusiones opticas presentadas en su mayoria basadas en movimiento provocaron que los ojos humanos viera fenomenos difernetes a como se ejecutaban en realidad, esto debido a interpretaciones de nuestro cerebro ante diferens circunstacias que cambiaban por difernetes cirucunstacias, en el primero provcada por el fondo, en el segundo por el cambio de color sucesivo de los circulos de color rosa, el tercero por el movimiento y la sobreposicion de algunos arcos sobre otros, y el ultimo por el movimiento translacional de los dos arcos exteriores a los circulos\nReferences # Steping Illusion, Autor: Muchael Bach, Tomado de https://michaelbach.de/ot/mot-feetLin/index.html Complementary Colors, Autor: Michael Bach, Tomado de https://michaelbach.de/ot/col-lilacChaser/index.html Spinning Ellipses, Autor: Computing Masterclass, Tomado de: https://youtu.be/xlPWCrjQsTE Moving Dots, Autor: Computing Masterclass, Tomado de : https://youtu.be/BQbrx6V0jTs "},{"id":1,"href":"/VisualComputing/docs/taller-2/camaras/","title":"Múltiples Cámaras","section":"Taller 2","content":" Múltiples Cámaras # Introducción - Descripción de la idea # Para este proyecto se tomo como referencia las cámaras de punto fijo de los juegos de Resident Evil clásicos en los que se jugaba con una cámara de punto fijo:\nTanto el punto de vista como el cambio en las transiciones\nSe hizo uso de transformaciones en el espacio y de cámaras con quaterniones, los cuaterniones son muy ́utiles en la representación gráfica por ordenador, debido, entre otras cosas, a la posibilidad que ofrecen de representar con ellos rotaciones en el espacio tridimensional a través de los ángulos de Euler evitando el Gimbal Lock-Bloqueo del cardán. (Deformación de la imagen por perdida de libertad).\nCódigo /** * * The p5.EasyCam library - Easy 3D CameraControl for p5.js and WEBGL. * * Copyright 2018-2020 by p5.EasyCam authors * * Source: https://github.com/freshfork/p5.EasyCam * * MIT License: https://opensource.org/licenses/MIT * * * explanatory notes: * * p5.EasyCam is a derivative of the original PeasyCam Library by Jonathan Feinberg * and combines new useful features with the great look and feel of its parent. * * */ // // SplitView setup // // Two cameras, each one owns its own rendertarget. // // class wall { constructor(tlX, tlY, r, g, b, sX, sY){ this.tlX = tlX; this.tlY = tlY; this.r = r; this.g = g; this.b = b; this.sX = sX; this.sY = sY; } } const walls = [] walls.push(new wall(0, -75, 128, 64, 0, 90, 10)); walls.push(new wall(90, -75, 255,255,255, 90, 10)); walls.push(new wall(-90, -75, 255,255,255, 90, 10)); walls.push(new wall(140, -50, 255,255,255, 10, 60)); walls.push(new wall(-140, -50, 255,255,255, 10, 60)); walls.push(new wall(-75, 140, 255,255,255, 120, 10)); walls.push(new wall(75, 140, 255,255,255, 120, 10)); walls.push(new wall(-140, 90, 255,255,255, 10, 110)); walls.push(new wall(140, 90, 255,255,255, 10, 110)); walls.push(new wall(40, 90, 255,255,255, 5, 90)); walls.push(new wall(-40, 90, 255,255,255, 5, 90)); walls.push(new wall(-170, 40, 255, 255, 255, 50, 10)); walls.push(new wall(-170, 95, 128, 64, 0, 50, 10)); walls.push(new wall(-140, 290, 255,255,255, 10, 290)); walls.push(new wall(-280, 290, 255,255,255, 10, 290)); walls.push(new wall(-210, 440, 255,255,255, 150, 10)); walls.push(new wall(-280, 90, 255,255,255, 10, 110)); walls.push(new wall(-250, 95, 128,64,0, 50, 10)); walls.push(new wall(-250, 40, 255,255,255, 50, 10)); walls.push(new wall(-360, 140, 255,255,255, 150, 10)); walls.push(new wall(-345, 40, 255,255,255, 120, 10)); walls.push(new wall(-440, 90, 255,255,255, 10, 110)); walls.push(new wall(-520, 140, 2055,255,255, 150, 10)); walls.push(new wall(-535, 40, 255,255,255, 120, 10)); walls.push(new wall(-600, 90, 255,255,255, 10, 110)); walls.push(new wall(-630, 40, 255,255,255, 50, 10)); walls.push(new wall(-630, 95, 128,64,0, 50, 10)); walls.push(new wall(-600, 290, 255,255,255, 10, 290)); walls.push(new wall(-740, 290, 255,255,255, 10, 290)); walls.push(new wall(-670, 440, 255,255,255, 150, 10)); walls.push(new wall(-740, 90, 255,255,255, 10, 110)); walls.push(new wall(-710, 95, 128,64,0, 50, 10)); walls.push(new wall(-710, 40, 255,255,255, 50, 10)); walls.push(new wall(-770, 40, 255,255,255, 50, 10)); walls.push(new wall(-780, 140, 255,255,255, 70, 10)); walls.push(new wall(-820, 57.5, 255,255,255, 10, 175)); walls.push(new wall(-780, -25, 255,255,255, 70, 10)); walls.push(new wall(-740, -60, 255,255,255, 10, 80)); walls.push(new wall(-670, -105, 255,255,255, 150, 10)); walls.push(new wall(-600, -60, 255,255,255, 10, 80)); walls.push(new wall(-370, -25, 255,255,255, 450, 10)); walls.push(new wall(170, 40, 255,255,255, 50, 10)); walls.push(new wall(170, 95, 128,64,0, 50, 10)); walls.push(new wall(140, 290, 255,255,255, 10, 290)); walls.push(new wall(280, 290, 255,255,255, 10, 290)); walls.push(new wall(210, 440, 255,255,255, 150, 10)); walls.push(new wall(280, 90, 255,255,255, 10, 110)); walls.push(new wall(250, 95, 128,64,0, 50, 10)); walls.push(new wall(250, 40, 255,255,255, 50, 10)); walls.push(new wall(360, 140, 255,255,255, 150, 10)); walls.push(new wall(345, 40, 255,255,255, 120, 10)); walls.push(new wall(440, 90, 255,255,255, 10, 110)); walls.push(new wall(520, 140, 255,255,255, 150, 10)); walls.push(new wall(535, 40, 255,255,255, 120, 10)); walls.push(new wall(600, 90, 255,255,255, 10, 110)); walls.push(new wall(630, 40, 255,255,255, 50, 10)); walls.push(new wall(630, 95, 128,64,0, 50, 10)); walls.push(new wall(600, 290, 255,255,255, 10, 290)); walls.push(new wall(740, 290, 255,255,255, 10, 290)); walls.push(new wall(670, 440, 255,255,255, 150, 10)); walls.push(new wall(740, 90, 255,255,255, 10, 110)); walls.push(new wall(710, 95, 128,64,0, 50, 10)); walls.push(new wall(710, 40, 255,255,255, 50, 10)); walls.push(new wall(770, 40, 255,255,255, 50, 10)); walls.push(new wall(780, 140, 255,255,255, 70, 10)); walls.push(new wall(820, 57.5, 255,255,255, 10, 175)); walls.push(new wall(780, -25, 255,255,255, 70, 10)); walls.push(new wall(740, -60, 255,255,255, 10, 80)); walls.push(new wall(670, -105, 255,255,255, 150, 10)); walls.push(new wall(600, -60, 255,255,255, 10, 80)); walls.push(new wall(370, -25, 255,255,255, 450, 10)); class camState { constructor(distance, center, rotation){ this.distance = distance; this.center = center; this.rotation = rotation; } } const cams = [] //0 //cams.push(new camState(900, [-200, 0, 0], [0, 0, 0, 1])); //1 cams.push(new camState(197, [0, 0, 0], [0.006, -0.001, -0.109, 1])); //2 cams.push(new camState(130, [0, 60, 0], [-0.915, -0.332, -0.074, 0.211])); //3 cams.push(new camState(130, [90, 60, 0], [-0.910, -0.335, 0.098, -0.220])); //4 cams.push(new camState(130, [-90, 60, 0], [-0.910, -0.335, 0.098, -0.220])); //5 cams.push(new camState(132, [-210, 0, 0], [-0.002, 0, -0.033, 1])); //6 cams.push(new camState(120, [-210, 60, 0], [0.689, 0.191, -0.113, 0.677])); //7 cams.push(new camState(180, [-210, 270, 0], [ -0.873, -0.459, 0.104, -0.118])); //8 cams.push(new camState(134, [-360, 0, 0], [ 0.668, 0.256, 0.180, -0.674])); //9 cams.push(new camState(117, [-360, 90, 0], [ 0.794, 0.33, -0.195, 0.468])); //10 cams.push(new camState(113, [-510, 0, 0], [ 0.671, 0.284, -0.245, 0.649])); //11 cams.push(new camState(113, [-510, 90, 0], [ -0.515, -0.189, -0.354, 0.756])); //12 cams.push(new camState(120, [-720, 0, 0], [ 0.563, 0.249, 0.241, -0.749])); //13 cams.push(new camState(134, [-660, -45, 0], [ 0, -0.003, 0.164, -0.986])); //14 cams.push(new camState(120, [-660, 60, 0], [0.689, 0.191, 0.191, -0.687])); //15 cams.push(new camState(190, [-660, 270, 0], [ 0.855, 0.478, 0.105, -0.169])); //16 cams.push(new camState(100, [-765, 90, 0], [ .920, 0.161, 0.046, 0.351])); //17 cams.push(new camState(132, [210, 0, 0], [-0.002, 0, -0.033, 1])); //18 cams.push(new camState(120, [210, 60, 0], [0.689, 0.191, -0.113, 0.677])); //19 cams.push(new camState(180, [210, 270, 0], [ 0.852, 0.485, 0.100, -0.163])); //20 cams.push(new camState(134, [360, 0, 0], [ -0.668, -0.256, 0.180, -0.674])); //21 cams.push(new camState(117, [360, 90, 0], [ 0.794, 0.33, -0.195, 0.468])); //22 cams.push(new camState(113, [510, 0, 0], [ 0.671, 0.284, 0.245, -0.649])); //23 cams.push(new camState(100, [510, 90, 0], [ 0.810, 0.351, 0.185, -0.429])); //24 cams.push(new camState(130, [720, 0, 0], [ -0.671, -0.284, 0.237, -0.642])); //25 cams.push(new camState(134, [660, -45, 0], [ 0, -0.003, 0.164, -0.986])); //26 cams.push(new camState(105, [660, 60, 0], [0.689, 0.191, 0.191, -0.687])); //27 cams.push(new camState(190, [660, 270, 0], [ 0.864, 0.482, 0.061, -0.127])); //28 cams.push(new camState(100, [765, 90, 0], [ 0.869, 0.291, -0.138, 0.374])); var currentCam = 1; var camX; var camY; var camZ; class room { constructor(X1, X2, Y1, Y2){ this.X1 = X1; this.X2 = X2; this.Y1 = Y1; this.Y2 = Y2; } } const rooms = [] rooms.push(new room(-140, 140, -75, 45)); rooms.push(new room(-40, 40, 45, 135)); rooms.push(new room(40, 130, 45, 135)); rooms.push(new room(-130, -40, 45, 135)); rooms.push(new room(-280, -140, -15, 30)); rooms.push(new room(-280, -140, 40, 95)); rooms.push(new room(-280, -140, 105, 430)); rooms.push(new room(-440, -290, -15, 30)); rooms.push(new room(-430, -290, 40, 130)); rooms.push(new room(-590, -440, -15, 30)); rooms.push(new room(-590, -450, 40, 130)); rooms.push(new room(-810, -600, -15, 30)); rooms.push(new room(-730, -610, -95, -25)); rooms.push(new room(-730, -610, 40, 95)); rooms.push(new room(-730, -610, 105, 430)); rooms.push(new room(-810, -750, 40, 130)); rooms.push(new room(140, 280, -15, 30)); rooms.push(new room(140, 280, 40, 95)); rooms.push(new room(140, 280, 105, 430)); rooms.push(new room(290, 440, -15, 30)); rooms.push(new room(290, 430, 40, 130)); rooms.push(new room(440, 590, -15, 30)); rooms.push(new room(450, 590, 40, 130)); rooms.push(new room(600, 810, -15, 30)); rooms.push(new room(610, 730, -95, -25)); rooms.push(new room(610, 730, 40, 95)); rooms.push(new room(610, 730, 105, 430)); rooms.push(new room(750, 810, 40, 130)); var currentRoom = 0; var x=0, y=20; var playerX = 0; var playerY = 0; var playerNextX = 0; var playerNextY = 0; var playerFacing = 0; var playerSpeed = 2; let floor_texture; let wall_texture; let door_texture; function preload() { f = loadFont(\u0026#39;https://cdnjs.cloudflare.com/ajax/libs/ink/3.1.10/fonts/Roboto/roboto-regular-webfont.ttf\u0026#39;); floor_texture = loadImage(\u0026#39;/VisualComputing/sketches/textures_models/floor_texture.jpeg\u0026#39;); wall_texture = loadImage(\u0026#39;/VisualComputing/sketches/textures_models/wall1_texture.jpg\u0026#39;); door_texture = loadImage(\u0026#39;/VisualComputing/sketches/textures_models/wall6_texture.jpg\u0026#39;); modelPlayer = loadModel(\u0026#39;/VisualComputing/sketches/textures_models/player.obj\u0026#39;); modelCharizard = loadModel(\u0026#39;/VisualComputing/sketches/textures_models/charizard.obj\u0026#39;); textureCharizard = loadImage(\u0026#39;/VisualComputing/sketches/textures_models/charizard.jpg\u0026#39;); modelBulbasaur = loadModel(\u0026#39;/VisualComputing/sketches/textures_models/bulbasaur.obj\u0026#39;); textureBulbasaur = loadImage(\u0026#39;/VisualComputing/sketches/textures_models/bulbasaur.jpg\u0026#39;); modelSquirtle = loadModel(\u0026#39;/VisualComputing/sketches/textures_models/squirtle.obj\u0026#39;); textureSquirtle = loadImage(\u0026#39;/VisualComputing/sketches/textures_models/squirtle.jpg\u0026#39;); modelScyther = loadModel(\u0026#39;/VisualComputing/sketches/textures_models/scyther.obj\u0026#39;); textureScyther = loadImage(\u0026#39;/VisualComputing/sketches/textures_models/scyther.jpg\u0026#39;); } document.oncontextmenu = function() { return false; } var easycam1, easycam2; function setup() { frameRate(30) var w = 800; var h = 800; var canvas = createCanvas(w, h, WEBGL); var graphics1 = createGraphics(w, h, WEBGL) var graphics2 = createGraphics(w, h, WEBGL); easycam1 = new Dw.EasyCam(graphics1._renderer); easycam2 = new Dw.EasyCam(graphics2._renderer); easycam1.setState(cams[0], 0); easycam2.setState({distance: 100, center : [0, 0, 0], rotation : [0, 0, 0, 1]}, 0); //easycam1.attachMouseListeners(this._renderer); //easycam2.attachMouseListeners(this._renderer); // set viewports easycam1.setViewport([0,0,w,h]); easycam2.setViewport([Math.floor(3*w/4),0,Math.floor(w/4),Math.floor(h/4)]); } function draw(){ clear(); easycam2.setCenter([playerX, playerY, 0], 0); playerNextX = playerX; playerNextY = playerY; for (let i = 0; i \u0026lt; rooms.length; i++) { if (rooms[i].X1 \u0026lt;= playerX \u0026amp;\u0026amp; playerNextX \u0026lt;= rooms[i].X2 \u0026amp;\u0026amp; rooms[i].Y1 \u0026lt;= playerY \u0026amp;\u0026amp; playerY \u0026lt;= rooms[i].Y2) { easycam1.setState(cams[i], 0); currentRoom = i; currentCam = i; break; } } if (keyIsPressed === true) { switch(keyCode) { case 87://W playerNextY = playerY + playerSpeed; playerFacing = 2; break; case 83://S playerNextY = playerY - playerSpeed; playerFacing = 0; break; case 68://D playerNextX = playerX - playerSpeed; playerFacing = 3; break; case 65://A playerNextX = playerX + playerSpeed; playerFacing = 1; break; case 69://E playerSpeed = playerSpeed + 0.1; break; case 81://Q playerSpeed = playerSpeed - 0.1; break; default: } } for (let i = 0; i \u0026lt; walls.length; i++) { if (walls[i].tlY-(walls[i].sY/2) \u0026lt; playerNextY+5 \u0026amp;\u0026amp; playerNextY-5 \u0026lt; walls[i].tlY+(walls[i].sY/2) \u0026amp;\u0026amp; walls[i].tlX-(walls[i].sX/2) \u0026lt; playerNextX+5 \u0026amp;\u0026amp; playerNextX-5 \u0026lt; walls[i].tlX+(walls[i].sX/2)) { playerNextY = playerY playerNextX = playerX } } playerX = playerNextX playerY = playerNextY var g1 = easycam1.graphics; var g2 = easycam2.graphics; g1.clear(); g2.clear(); // projection g1.perspective(); // BG g1.background(32); g1.noStroke(); // lights g1.ambientLight(10); g1.pointLight(35, 30, 30, 0, 0, 100); //floor g1.push(); g1.translate(0, 0, 0); g1.ambientMaterial(255,255,255); g1.texture(floor_texture); g1.box(2000, 1200, 1); g1.pop(); // player g1.push(); g1.translate(playerX, playerY, 0); g1.ambientMaterial(0,0,0); g1.scale(2); g1.rotateX(PI/2*(-3)); g1.rotateY(playerFacing*PI/2*(-3)); g1.model(modelPlayer); //g1.box(10, 10, 30); g1.pop(); // Charizard g1.push(); g1.translate(230, 380, 12); g1.ambientMaterial(0,0,0); g1.scale(0.15); g1.texture(textureCharizard); g1.rotateX(PI/2*(-0.9)); g1.rotateY(PI/2*(-2)); g1.model(modelCharizard); g1.pop(); // Bulbasaur g1.push(); g1.translate(-800, 0, 0); g1.ambientMaterial(0,0,0); g1.scale(0.05); g1.texture(textureBulbasaur); g1.rotateX(PI/2*(-1)); g1.rotateY(PI/2*(1)); g1.model(modelBulbasaur); g1.pop(); // Squirtle g1.push(); g1.translate(755, 60, 0); g1.ambientMaterial(0,0,0); g1.scale(0.10); g1.texture(textureSquirtle); g1.rotateX(PI/2*(-0.9)); g1.rotateY(PI/2*(-1.6)); g1.model(modelSquirtle); g1.pop(); // Scyther g1.push(); g1.translate(-360, 90, 22); g1.ambientMaterial(0,0,0); g1.scale(0.17); g1.texture(textureScyther); g1.rotateX(PI/2*(-1)); g1.rotateY(PI/2*(1)); g1.model(modelScyther); g1.pop(); for (let i = 0; i \u0026lt; walls.length; i++) { g1.push(); g1.translate(walls[i].tlX, walls[i].tlY, 50); g1.ambientMaterial(walls[i].r, walls[i].g, walls[i].b); g1.box(walls[i].sX, walls[i].sY, 100); g1.pop(); } g2.ortho(-width/7, width/7, -height/7, height/7); // BG g2.background(32); g2.noStroke(); // lights // g2.ambientLight(35); // g2.pointLight(10, 10, 10, 0, 0, 50); //floor // g2.push(); // g2.translate(0, 0, 0); // g2.ambientMaterial(255,255,255); // g2.box(2000, 1200, 1); // g2.pop(); // player g2.push(); g2.translate(playerX, playerY, 15.5); g2.ambientMaterial(0,0,0); g2.box(10, 10, 30); g2.pop(); for (let i = 0; i \u0026lt; walls.length; i++) { g2.push(); g2.translate(walls[i].tlX, walls[i].tlY, 50); g2.ambientMaterial(walls[i].r, walls[i].g, walls[i].b); g2.box(walls[i].sX, walls[i].sY, 100); g2.pop(); } // 2D screen-aligned rendering section easycam1.beginHUD(); let state = easycam1.getState(); // Render the background box for the HUD g1.noStroke(); g1.fill(50,50,52, 200); // a bit of transparency g1.rect(x+20,y,380,200); // use the loaded font g1.textFont(f); g1.textSize(16); g1.stroke(50,50,52); g1.strokeWeight(0.5); // Render the labels g1.fill(69,161,255); g1.text(\u0026#34;Camera:\u0026#34;,x+35,y+25); g1.text(\u0026#34;Room:\u0026#34;,x+35,y+25+20); g1.text(\u0026#34;Distance:\u0026#34;,x+35,y+25+40); g1.text(\u0026#34;Center: \u0026#34;,x+35,y+25+60); g1.text(\u0026#34;Rotation:\u0026#34;,x+35,y+25+80); g1.text(\u0026#34;Framerate:\u0026#34;,x+35,y+25+100); g1.text(\u0026#34;playerX:\u0026#34;,x+35,y+25+120); g1.text(\u0026#34;playerY:\u0026#34;,x+35,y+25+140); g1.text(\u0026#34;playerSpeed:\u0026#34;,x+35,y+25+160); // Render the state numbers g1.fill(69,161,255); g1.text(currentCam,x+125,y+25); g1.text(currentRoom,x+125,y+25+20); g1.text(nfs(state.distance, 1, 2),x+125,y+25+40); g1.text(nfs(state.center, 1, 2),x+125,y+25+60); g1.text(nfs(state.rotation, 1, 3),x+125,y+25+80); g1.text(nfs(frameRate(), 1, 2),x+125,y+25+100); g1.text(nfs(playerX, 1, 2),x+125,y+25+120); g1.text(nfs(playerY, 1, 2),x+125,y+25+140); g1.text(nfs(playerSpeed, 1, 2),x+125,y+25+160); easycam1.endHUD(); // display results displayResult_WEBGL(); } // use this, when the main canvas is WEBGL ... createCanvas(w,h,WEBGL) function displayResult_WEBGL(){ var vp1 = easycam1.getViewport(); var vp2 = easycam2.getViewport(); resetMatrix(); ortho(0, width, -height, 0, -Number.MAX_VALUE, +Number.MAX_VALUE); texture(easycam1.graphics); rect(vp1[0], vp1[1], vp1[2], vp1[3]); texture(easycam2.graphics); rect(vp2[0], vp2[1], vp2[2], vp2[3]); } Conclusiones # Es posible crear un entorno 3D virtual con solo dos dimensiones, controlando los ángulos implicados en el proceso y evitando la deformación espacial por las perspectivas, existen librerias especificas para este propósito, entre ellas están EasyCam que ya han hecho todo el trabajo matemático para permitir crear estos entornos con instrucciones simplificadas. References # EasyCam https://github.com/freshfork/p5.EasyCam Carratalá Rocío, Tomado de http://repositori.uji.es/xmlui/bitstream/handle/10234/139036/TFG_2015_CarratalaSaezR.pdf?sequence=1 "},{"id":2,"href":"/VisualComputing/docs/taller-1/convolucion/","title":"Convolución","section":"Taller 1","content":" Marco Teorico # Convolución # 1. Identity: La mascara retorna la misma imagen\n\\[\\begin{bmatrix} 0 \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; 1 \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; 0 \\end{bmatrix}\\] 2. Sharpen: El núcleo de nitidez enfatiza las diferencias en los valores de píxeles adyacentes, lo que hace que la imagen parezca más vívida.\n\\[\\begin{bmatrix} 0 \u0026amp; -1 \u0026amp; 0\\\\ -1 \u0026amp; 5 \u0026amp; -1\\\\ 0 \u0026amp; -1 \u0026amp; 0 \\end{bmatrix}\\] 3. Emboss: Es una técnica de gráficos por computadora en la que cada píxel de una imagen se reemplaza por un resaltado o una sombra, según los límites claros/oscuros de la imagen original. Las áreas de bajo contraste se reemplazan por un fondo gris\n\\[\\begin{bmatrix} -2 \u0026amp; -1 \u0026amp; 0\\\\ -1 \u0026amp; 2 \u0026amp; 1\\\\ 0 \u0026amp; 1 \u0026amp; 2 \\end{bmatrix}\\] 4. Outline:\n\\[\\begin{bmatrix} -1 \u0026amp; -1 \u0026amp; -1\\\\ -1 \u0026amp; 9 \u0026amp; -1\\\\ -1 \u0026amp; 1 \u0026amp; -1 \\end{bmatrix}\\] 5. Gaussian-blur: es el resultado de desenfocar una imagen por una función gaussiana (llamada así por el matemático y científico Carl Friedrich Gauss).\n\\[\\begin{bmatrix} 1 \u0026amp; 2 \u0026amp; 1\\\\ 2 \u0026amp; 4 \u0026amp; 1\\\\ 1 \u0026amp; 2 \u0026amp; 1 \\end{bmatrix}\\] El operador Sobel es utilizado en procesamiento de imágenes, especialmente en algoritmos de detección de bordes. Técnicamente es un operador diferencial discreto que calcula una aproximación al gradiente de la función de intensidad de una imagen. Para cada punto de la imagen a procesar, el resultado del operador Sobel es tanto el vector gradiente correspondiente como la norma de este vector.\n6. Left-sobel:\n\\[\\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; -1\\\\ 2 \u0026amp; 1 \u0026amp; -2\\\\ 1 \u0026amp; 0 \u0026amp; -1 \\end{bmatrix}\\] 7. Right-sobel:\n\\[\\begin{bmatrix} -1 \u0026amp; 0 \u0026amp; 1\\\\ -2 \u0026amp; 1 \u0026amp; 2\\\\ -1 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}\\] 8. Top-sobel:\n\\[\\begin{bmatrix} 1 \u0026amp; 2 \u0026amp; 1\\\\ 0 \u0026amp; 1 \u0026amp; 0\\\\ -1 \u0026amp; -2 \u0026amp; -1 \\end{bmatrix}\\] 9. Botton-sobel:\n\\[\\begin{bmatrix} -1 \u0026amp; -2 \u0026amp; -1\\\\ 0 \u0026amp; 1 \u0026amp; 0\\\\ 1 \u0026amp; 2 \u0026amp; 1 \\end{bmatrix}\\] Ejercicio # Ejecuciòn Còdigo Lightness # Se utilizaron las siguientes ecuaciones para calcular la constante por la cual se multiplicó el calor de cada pixel.\nHSI\n\\(L = \\frac{1}{3}\\times(cR \u0026#43; cG \u0026#43; cB) \\to c = \\frac{3L}{(R \u0026#43; G \u0026#43; B)}\\) HSV\n\\(L = \\max(cR, cG, cB) \\to c = \\frac{L}{\\max(R, G, B)}\\) HSL\n\\(L = \\frac{1}{2}\\times(\\max(cR, cG, cB) \u0026#43; \\min(cR, cG, cB)) \\to c = \\frac{2L}{\\max(R, G, B) \u0026#43; \\min(R, G, B)}\\) Luma (601)\n\\(L = 0.2989cR \u0026#43; 0.5870cG \u0026#43; 0.1140cB \\to c = \\frac{L}{0.2989R \u0026#43; 0.5870G \u0026#43; 0.1140B}\\) Código # \u0026lt;img hidden id=\u0026#34;uploaded-image\u0026#34; src=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;!--imagen subida, de ella se obtiene la representación binaria que luego es usada por el canvas para obtener la representación en RGBA --\u0026gt; \u0026lt;canvas hidden id=\u0026#34;canvas-for-rgba\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; \u0026lt;!-- canvas solo para dibujar la imagen subida y obtener la representación en RGBA, por eso puede ser oculta --\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; id=\u0026#34;image-input\u0026#34; accept=\u0026#34;image/jpeg, image/png, image/jpg\u0026#34;\u0026gt; Kernel: \u0026lt;select id=\u0026#34;kernel-select\u0026#34;\u0026gt; \u0026lt;option selected value=\u0026#34;identity\u0026#34;\u0026gt;Identity\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;gaussian-blur\u0026#34;\u0026gt;Gaussian Blur\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;sharpen\u0026#34;\u0026gt;Sharpen\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;outline\u0026#34;\u0026gt;Outline\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;emboss\u0026#34;\u0026gt;Emboss\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;left-sobel\u0026#34;\u0026gt;Left Sobel\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;right-sobel\u0026#34;\u0026gt;Right Sobel\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;top-sobel\u0026#34;\u0026gt;Top Sobel\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;bottom-sobel\u0026#34;\u0026gt;Bottom Sobel\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;input hidden id=\u0026#34;lightness-input\u0026#34; type=\u0026#34;number\u0026#34; placeholder=\u0026#34;Lightness\u0026#34;\u0026gt;\u0026lt;/input\u0026gt; \u0026lt;select hidden id=\u0026#34;lightness-definition-select\u0026#34;\u0026gt; \u0026lt;option selected value=\u0026#34;HSI\u0026#34;\u0026gt;HSI\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;HSV\u0026#34;\u0026gt;HSV\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;HSL\u0026#34;\u0026gt;HSL\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;Luma 601\u0026#34;\u0026gt;Luma 601\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;Luma 240\u0026#34;\u0026gt;Luma 240\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;Luma 709\u0026#34;\u0026gt;Luma 709\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;Luma 2020\u0026#34;\u0026gt;Luma 2020\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;canvas id=\u0026#34;transformed-image-canvas\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; \u0026lt;!-- Load d3.js --\u0026gt; \u0026lt;script src=\u0026#34;https://d3js.org/d3.v4.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- Create a div where the graph will take place --\u0026gt; \u0026lt;div id=\u0026#34;red-histogram\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;green-histogram\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;blue-histogram\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; function bound(color) { if (color \u0026gt; 255) return 255 else if (color \u0026lt; 0) return 0 return color } function applyLightness(image, width, height) { let L = document.querySelector(\u0026#39;#lightness-input\u0026#39;).value if (L == \u0026#39;\u0026#39;) return; let canvas = document.querySelector(\u0026#34;#canvas-for-rgba\u0026#34;); canvas.width = width; canvas.height = height; var ctx = canvas.getContext(\u0026#34;2d\u0026#34;); ctx.drawImage(image, 0, 0); var data = ctx.getImageData(0, 0, width, height).data; lightness_data = [] let R_array = [] let G_array = [] let B_array = [] let def = document.querySelector(\u0026#39;#lightness-definition-select\u0026#39;).value for (let i = 0; i \u0026lt; data.length; i += 4) { let r = data[i]; let g = data[i + 1]; let b = data[i + 2]; let a = data[i + 3]; let c = constant(L, r, g, b, def) let cr = c * r let cg = c * g let cb = c * b let R = bound(Math.round(cr)) let G = bound(Math.round(cg)) let B = bound(Math.round(cb)) let A = a R_array.push(R) G_array.push(G) B_array.push(B) lightness_data.push(R) lightness_data.push(G) lightness_data.push(B) lightness_data.push(A) } canvas = document.querySelector(\u0026#34;#transformed-image-canvas\u0026#34;); canvas.width = width; canvas.height = height; ctx = canvas.getContext(\u0026#34;2d\u0026#34;); var imageData = canvas.getContext(\u0026#39;2d\u0026#39;).createImageData(width, height); imageData.data.set(lightness_data); ctx.putImageData(imageData, 0, 0) drawHistogram(R_array, \u0026#39;red\u0026#39;); drawHistogram(G_array, \u0026#39;green\u0026#39;); drawHistogram(B_array, \u0026#39;blue\u0026#39;); } // función de procesamiento de la imagen function processImage(image, width, height) { let canvas = document.querySelector(\u0026#34;#canvas-for-rgba\u0026#34;); canvas.width = width; canvas.height = height; var ctx = canvas.getContext(\u0026#34;2d\u0026#34;); ctx.drawImage(image, 0, 0); var data = ctx.getImageData(0, 0, width, height).data; // data es un arreglo con los valores RGBA de la imagen (arreglo unidimensional) transformed_data = [] // es el arreglo transformado o procesado let ker = kernel(document.querySelector(\u0026#39;#kernel-select\u0026#39;).value) // kernel a usar let R_array = [] let G_array = [] let B_array = [] for (let i = 0; i \u0026lt; data.length; i += 4) { // se itera de 4, i corresponde al valor R del pixel i-ésimo de la imagen let r = data[i]; let g = data[i + 1]; let b = data[i + 2]; let a = data[i + 3]; let pos = position(i, width, height) let nbs = neighbours(i, pos, width) let ws = weights(ker, pos) let sum = ws.reduce((partialSum, a) =\u0026gt; partialSum + a, 0); // en la matriz se debe garantizar que la suma de los pesos no sea cero para que funcione let rtotal = 0 let gtotal = 0 let btotal = 0 let atotal = 0 // suma ponderada para cada valor R G B A for (let j = 0; j \u0026lt; nbs.length; j++) { rtotal += data[nbs[j]] * ws[j] gtotal += data[nbs[j] + 1] * ws[j] btotal += data[nbs[j] + 2] * ws[j] atotal += data[nbs[j] + 3] * ws[j] } // se obtiene la suma ponderada: error cuando sum es cero ... let R = Math.round(rtotal / sum) let G = Math.round(gtotal / sum) let B = Math.round(btotal / sum) let A = Math.round(atotal / sum) R_array.push(R) G_array.push(G) B_array.push(B) // se agregan los nuevos valores al arreglo transformado transformed_data.push(R) transformed_data.push(G) transformed_data.push(B) transformed_data.push(A) } // se crea canvas de la imagen transformada para mostrarla en pantalla // nota: se necesita usar canvas para poder visualizar la imagen apartir del arreglo de R G B A canvas = document.querySelector(\u0026#34;#transformed-image-canvas\u0026#34;); canvas.width = width; canvas.height = height; ctx = canvas.getContext(\u0026#34;2d\u0026#34;); var imageData = canvas.getContext(\u0026#39;2d\u0026#39;).createImageData(width, height); imageData.data.set(transformed_data); ctx.putImageData(imageData, 0, 0) drawHistogram(R_array, \u0026#39;red\u0026#39;); drawHistogram(G_array, \u0026#39;green\u0026#39;); drawHistogram(B_array, \u0026#39;blue\u0026#39;); } // se procesa imagen cuando se sube archivo const image_input = document.querySelector(\u0026#34;#image-input\u0026#34;); image_input.addEventListener(\u0026#34;change\u0026#34;, function() { const reader = new FileReader(); reader.readAsDataURL(this.files[0]); reader.onload = (e) =\u0026gt; { const image = new Image(); image.src = e.target.result; image.onload = (e) =\u0026gt; { const width = e.target.width; const height = e.target.height; const uploaded_image = reader.result document.querySelector(\u0026#34;#uploaded-image\u0026#34;).src = uploaded_image; processImage(image, width, height) document.querySelector(\u0026#39;#lightness-input\u0026#39;).removeAttribute(\u0026#34;hidden\u0026#34;); document.querySelector(\u0026#39;#lightness-definition-select\u0026#39;).removeAttribute(\u0026#39;hidden\u0026#39;) }; }; }); // se procesa imagen cuando se cambia el valor del select kernel const kernel_select = document.querySelector(\u0026#34;#kernel-select\u0026#34;); kernel_select.addEventListener(\u0026#34;change\u0026#34;, function() { const image = new Image(); let img = document.querySelector(\u0026#34;#uploaded-image\u0026#34;) image.src = img.src; let width = img.width let height = img.height processImage(image, width, height) }); // se procesa imagen cuando se cambia el valor del select kernel const lightness_input = document.querySelector(\u0026#34;#lightness-input\u0026#34;); lightness_input.addEventListener(\u0026#34;change\u0026#34;, function() { const image = new Image(); let img = document.querySelector(\u0026#34;#uploaded-image\u0026#34;) image.src = img.src; let width = img.width let height = img.height applyLightness(image, width, height) }); // se procesa imagen cuando se cambia el valor del select kernel const lightness_definition_select = document.querySelector(\u0026#34;#lightness-definition-select\u0026#34;); lightness_definition_select.addEventListener(\u0026#34;change\u0026#34;, function() { const image = new Image(); let img = document.querySelector(\u0026#34;#uploaded-image\u0026#34;) image.src = img.src; let width = img.width let height = img.height applyLightness(image, width, height) }); // obtener posición del pixel según su índice y los valores weight y height let position = (i, w, h) =\u0026gt; { if (i == 0) return \u0026#39;top-left-corner\u0026#39;; else if (i == (w * 4) - 1) return \u0026#39;top-right-corner\u0026#39;; else if (i == h * ((w * 4) - 1)) return \u0026#39;bottom-left-corner\u0026#39;; else if (i == (h * w * 4) - 1) return \u0026#39;bottom-right-corner\u0026#39;; else if (i \u0026lt; (w * 4) - 1) return \u0026#39;top-row\u0026#39;; else if (i % (w * 4) == (w * 4) - 1) return \u0026#39;right-row\u0026#39;; else if (i \u0026gt; h * ((w * 4) - 1) \u0026amp;\u0026amp; i \u0026lt; (h * w * 4) - 1) return \u0026#39;bottom-row\u0026#39;; else if (i % (w * 4) == 0) return \u0026#39;left-row\u0026#39;; else return \u0026#39;inner-cell\u0026#39; } // arreglo de índices según posición, que será usado para obtener las posiciones de los pixeles vecinos (neighbours) y // las posiciones de los pesos de la matriz del kernel let indexes = (position) =\u0026gt; { if (position == \u0026#39;inner-cell\u0026#39;) return [0, 1, 2, 3, 4, 5, 6, 7, 8] else if (position == \u0026#39;left-row\u0026#39;) return [ 1, 2, 4, 5, 7, 8] else if (position == \u0026#39;right-row\u0026#39;) return [0, 1, 3, 4, 6, 7 ] else if (position == \u0026#39;top-row\u0026#39;) return [ 3, 4, 5, 6, 7, 8] else if (position == \u0026#39;bottom-row\u0026#39;) return [0, 1, 2, 3, 4, 5, ] else if (position == \u0026#39;top-right-corner\u0026#39;) return [ 3, 4, 6, 7 ] else if (position == \u0026#39;top-left-corner\u0026#39;) return [ 4, 5, 7, 8] else if (position == \u0026#39;bottom-left-corner\u0026#39;) return [ 1, 2, 4, 5 ] else if (position == \u0026#39;bottom-right-corner\u0026#39;) return [0, 1, 3, 4 ] else return [] } // arreglo con los índices de los pixeles vecinos let neighbours = (i, position, w) =\u0026gt; { let matrix = [i - (w * 4) - 4, i - (w * 4), i - (w * 4) + 4, i - 4, i , i + 4, i + (w * 4) - 4, i + (w * 4), i + (w * 4) + 4] let idx = indexes(position) let nbs = [] idx.forEach((i) =\u0026gt; { nbs.push(matrix[i]) }) return nbs } // kernels disponibles: cada matriz es una matriz de pesos let kernel = (kernel) =\u0026gt; { if (kernel == \u0026#39;identity\u0026#39;) return [0, 0, 0, 0, 1, 0, 0, 0, 0] else if (kernel == \u0026#39;gaussian-blur\u0026#39;) return [1, 2, 1, 2, 4, 1, 1, 2, 1] else if (kernel == \u0026#39;emboss\u0026#39;) return [-2, -1, 0, -1, 2, 1, 0, 1, 2] else if (kernel == \u0026#39;left-sobel\u0026#39;) return [1, 0, -1, 2, 1, -2, 1, 0, -1] else if (kernel == \u0026#39;right-sobel\u0026#39;) return [-1, 0, 1, -2, 1, 2, // se agregó 1 en la posición central para garantizar que suma de pesos no sea cero -1, 0, 1] else if (kernel == \u0026#39;top-sobel\u0026#39;) return [1, 2, 1, 0, 1, 0, -1, -2, -1] else if (kernel == \u0026#39;bottom-sobel\u0026#39;) return [-1, -2, -1, 0, 1, 0, 1, 2, 1] else if (kernel == \u0026#39;sharpen\u0026#39;) return [0, -1, 0, -1, 5, -1, 0, -1, 0] else if (kernel == \u0026#39;outline\u0026#39;) return [-1, -1, -1, -1, 9, -1, -1, 1, -1] else return [] } // arreglo de pesos que se usarán en la suma ponderada del pixel actual: depende del kernel y de la posición del pixel let weights = (ker, position) =\u0026gt; { let idx = indexes(position) let ws = [] idx.forEach((i) =\u0026gt; { ws.push(ker[i]) }) return ws } let constant = (L, R, G, B, definition) =\u0026gt; { if (definition == \u0026#39;HSI\u0026#39;) return 3 * (L / (R + G + B)) else if (definition == \u0026#39;HSV\u0026#39;) return L / Math.max(R, G, B) else if (definition == \u0026#39;HSL\u0026#39;) return 2 * (L / (Math.min(R, G, B) + Math.max(R, G, B))) else if (definition == \u0026#39;Luma 601\u0026#39;) return L / (0.2989 * R + 0.5870 * G + 0.1140 * B) else if (definition == \u0026#39;Luma 240\u0026#39;) return L / (0.212 * R + 0.701 * G + 0.087 * B) else if (definition == \u0026#39;Luma 709\u0026#39;) return L / (0.2126 * R + 0.7152 * G + 0.0722 * B) else if (definition == \u0026#39;Luma 2020\u0026#39;) return L / (0.2627 * R + 0.6780 * G + 0.0593 * B) else return 1 } function drawHistogram(data, color) { let colors = { \u0026#39;red\u0026#39;: \u0026#39;#FF0000\u0026#39;, \u0026#39;green\u0026#39;: \u0026#39;#00FF00\u0026#39;, \u0026#39;blue\u0026#39;: \u0026#39;#0000FF\u0026#39; } var domain = [0, 255] var margin = { top: 30, right: 30, bottom: 30, left: 50 }, width = 460 - margin.left - margin.right, height = 400 - margin.top - margin.bottom; var x = d3 .scaleLinear() .domain(domain) .range([0, width]); var histogram = d3 .histogram() .domain(x.domain()) .thresholds(x.ticks(256)); var bins = histogram(data); d3 .select(`#${color}-histogram svg`).remove() var svg = d3 .select(`#${color}-histogram`) .append(\u0026#34;svg\u0026#34;) .attr(\u0026#34;width\u0026#34;, width + margin.left + margin.right) .attr(\u0026#34;height\u0026#34;, height + margin.top + margin.bottom) .append(\u0026#34;g\u0026#34;) .attr(\u0026#34;transform\u0026#34;, \u0026#34;translate(\u0026#34; + margin.left + \u0026#34;,\u0026#34; + margin.top + \u0026#34;)\u0026#34;); svg .append(\u0026#34;g\u0026#34;) .attr(\u0026#34;transform\u0026#34;, \u0026#34;translate(0,\u0026#34; + height + \u0026#34;)\u0026#34;) .call(d3.axisBottom(x)); var y = d3 .scaleLinear() .range([height, 0]) .domain([ 0, d3.max(bins, function(d) { return d.length; }) ]); svg.append(\u0026#34;g\u0026#34;).call(d3.axisLeft(y)); svg .selectAll(\u0026#34;rect\u0026#34;) .data(bins) .enter() .append(\u0026#34;rect\u0026#34;) .attr(\u0026#34;x\u0026#34;, 1) .attr(\u0026#34;transform\u0026#34;, function(d) { return \u0026#34;translate(\u0026#34; + x(d.x0) + \u0026#34;,\u0026#34; + y(d.length) + \u0026#34;)\u0026#34;; }) .attr(\u0026#34;width\u0026#34;, function(d) { return x(d.x1) - x(d.x0) - 1; }) .attr(\u0026#34;height\u0026#34;, function(d) { return height - y(d.length); }) .style(\u0026#34;fill\u0026#34;, colors[color]); } \u0026lt;/script\u0026gt; "}]